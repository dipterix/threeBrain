#' @title Read `FreeSurfer` surface and volume files
#' @author Zhengjia Wang
#' @details This function is under FreeSurfer license.
#' 1. Volumes:
#' 3D viewer uses `mri/brain.finalsurfs.mgz` from `FreeSurfer` to show the
#' volume information. `brain.finalsurfs.mgz` results from step 1 to 15 in `FreeSurfer`
#' command `recon-all`, which aligns the original `DICOM` image to `RAS` coordinate
#' system, resamples to volume with \code{256x256x256} voxels (trilinear by default,
#' check \url{https://mail.nmr.mgh.harvard.edu/pipermail/freesurfer/2018-August/058127.html}
#' for more information).
#'
#' 2. Surface:
#' There are two options for surface files. The first choice is using
#' `std.141` brain generated by `AFNI/SUMA`. This surface file re-calculates vertices
#' from standard 141 space, which averages the "surface" of 141 subjects. If you
#' want to map surface electrodes across different subjects, you might want to
#' consider this case as it's especially designed for surface mapping. However,
#' you'll need `AFNI/SUMA` installed to generate the surface file. The details
#' can be found via \url{https://openwetware.org/wiki/Beauchamp:CorticalSurfaceHCP},
#' and the `AFNI/SUMA` command related is `SurfToSurf`. Please generate the files
#' to `[FREESURFER SUBJECT DIR]/SUMA/`. The file name follows the convention of
#' `std.141.[lr]h.[SURFACE TYPE].[POSTFIX]`, where `lh` means left hemisphere and
#' `rh` means right hemisphere; `SURFACE TYPE` can be `pial`, `white`, `smoothwm`,
#' and `POSTFIX` can be `asc`, `gii`, `nii`. If multiple files for the same surface
#' type exists, the search order will be `asc > gii > nii`.
#' The other option is to use mesh files directly from freesurfer output located
#' at `[FREESURFER SUBJECT DIR]/surf`. If you want to use these surface, make sure
#' they are converted to `asc`, `gii` or `nii` format.
#'
#' 3. Electrode registration and transforms
#' This package provides two ways to map electrodes to standard space. For surface
#' electrodes, if standard 141 brain is provided, then the first option is to snap
#' electrodes to the nearest vertices in subject space. The key is the vertex number
#' matches across different subjects, hence the location of corresponding vertices
#' at template brain are the mapped electrode coordinates.
#' If standard 141 brain is missing, or the electrode type is `stereo EEG`, then
#' the second option is volume mapping. The idea is to map electrodes to `MNI305`
#' brain. The details can be found at \url{https://surfer.nmr.mgh.harvard.edu/fswiki/CoordinateSystems}.
#' To perform volume mapping, we need `FreeSurfer` folder `mri/tranforms`.
#' Currently, only linear `Talairach` transform matrix is supported (located at
#' `talairach.xfm`).
#'
#' 4. Coordinates
#' The 3D viewer in this package uses the center of volume as the origin (0, 0, 0).
#'
#' @param fs_subject_folder character, `FreeSurfer` subject folder, or `RAVE` subject folder
#' @param subject_name character, subject code to display with only letters and digits
#' @param additional_surface_type character array, additional surface types to load, such as `white`, `smoothwm`
#' @param use_cache logical, whether to use cached json files or from raw `FreeSurfer` files
#' @param use_141 logical, whether to use standard 141 brain for surface file
#' @name freesurfer_brain
#' @export
freesurfer_brain <- function(fs_subject_folder, subject_name,
                             additional_surface_type = NULL,
                             use_cache = TRUE, use_141 = TRUE){
  # Naming conventions
  #
  # Volume group:   Volume (YAB)
  # Volume:         brain.finalsurfs (YAB)
  #
  # Surface group:  Surface - pial (YAB)
  # Surface         Standard 141 Right Hemisphere - pial (YAB)
  #
  # Electrode container: Electrodes (YAB)
  # Electrode          : YAB, 1 - NA



  ##### Load volume and surface ####
  # fs_subject_folder = '~/rave_data/data_dir/congruency/YAB/rave/fs/'
  # subject_name = 'YAB'
  mustWork = TRUE


  # Main
  nibabel = reticulate::import('nibabel')

  # Find folders

  if( dir.exists(file.path(fs_subject_folder, 'rave', 'fs')) ){
    path_subject = normalizePath(file.path(fs_subject_folder, 'rave', 'fs'), mustWork = mustWork)
  }else{
    path_subject = normalizePath(fs_subject_folder, mustWork = mustWork)
  }
  path_cache = file.path(path_subject, 'RAVE')

  # Find target files
  path_brainfinal = normalizePath(file.path(path_subject, 'mri', 'brain.finalsurfs.mgz'), mustWork = mustWork)
  path_rawavg = normalizePath(file.path(path_subject, 'mri', 'rawavg.mgz'), mustWork = mustWork)
  path_xform = normalizePath(file.path(path_subject, 'mri', 'transforms', 'talairach.xfm'), mustWork = mustWork)
  path_suma = normalizePath(file.path(path_subject, 'SUMA'), mustWork = FALSE)
  path_surf = normalizePath(file.path(path_subject, 'surf'), mustWork = FALSE)

  # Get general information from fs output
  brain_finalsurf = nibabel$load(path_brainfinal)
  rawavg = nibabel$load(path_rawavg)
  # get Norig
  Norig = brain_finalsurf$header$get_vox2ras()
  Torig = brain_finalsurf$header$get_vox2ras_tkr()

  # get talairach tranform
  ss = readLines(path_xform)
  xfm = stringr::str_match(ss, '^([-]{0,1}[0-9.]+) ([-]{0,1}[0-9.]+) ([-]{0,1}[0-9.]+) ([-]{0,1}[0-9.]+)[;]{0,1}$')
  xfm = xfm[!is.na(xfm[,1]), -1, drop = FALSE]
  if( nrow(xfm) >= 3 ){
    xfm = xfm[1:3,1:4]
  }else{
    cat2('Cannot parse file talairach.xfm properly.', level = 'WARNING')
    xfm = cbind(diag(c(1,1,1)), 0)
  }
  xfm = as.numeric(xfm)
  dim(xfm) = c(3,4)
  xfm = rbind(xfm, c(0,0,0,1))

  # Tranforms
  # 1. For volume mapping
  # I have an RAS point on the surface (tkrR tkrA tkrS) ("Vertex RAS" from tksurfer) and want to compute the MNI305 RAS that corresponds to this point:
  #     MNI305RAS = TalXFM*Norig*inv(Torig)*[tkrR tkrA tkrS 1]'
  # TalXFM: subject/orig/transforms/talairach.xfm Norig: mri_info --vox2ras orig.mgz Torig: mri_info --vox2ras-tkr orig.mgz
  vox2vox_MNI305 = xfm %*% Norig %*% solve(Torig)
  # 2. mesh center, freesurfer origin is at [-128,-128,-128], therefore, 0,0,0 is c(128, 128, 128, 1) for fs CRS
  # and Norig %*% c(128, 128, 128, 1) is volume center relative to mesh center.
  mesh_center = -(Norig %*% c(128, 128, 128, 1))[1:3]


  ##### get volume 256x256x256 ####
  dir.create(path_cache, recursive = TRUE, showWarnings = FALSE)
  volume = NULL
  volume_shape = as.integer(brain_finalsurf$get_shape())
  group_volume = GeomGroup$new(name = sprintf('Volume (%s)', subject_name))
  group_volume$subject_code = subject_name
  cache_volume = file.path(path_cache, sprintf('%s_brain_finalsurfs.json', subject_name))
  # Read from cache
  if( use_cache && file.exists(cache_volume) ){
    # TODO: Read volume cache
    geom_brain_finalsurfs = DataCubeGeom$new(
      name = sprintf('brain.finalsurfs (%s)', subject_name), value = array(NA, dim = volume_shape),
      dim = volume_shape, half_size = volume_shape / 2, group = group_volume,
      position = c(0,0,0), cache_file = cache_volume)
  }else{
    unlink(cache_volume)
  }

  if(is.null(volume)){
    volume = brain_finalsurf$get_data()
    # Re-order the data according to Norig, map voxels to RAS coord - anatomical
    order_index = (Norig %*% c(1,2,3,0))[1:3]
    volume = aperm(volume, abs(order_index))
    sub = sprintf(c('%d:1', '1:%d')[(sign(order_index) + 3) / 2], dim(volume))
    volume = eval(parse(text = sprintf('volume[%s]', paste(sub, collapse = ','))))

    geom_brain_finalsurfs = DataCubeGeom$new(
      name = sprintf('brain.finalsurfs (%s)', subject_name), value = volume, dim = volume_shape,
      half_size = volume_shape / 2, group = group_volume, position = c(0,0,0),
      cache_file = cache_volume)
  }
  geom_brain_finalsurfs$subject_code = subject_name
  rm(volume)

  #### Read surface files ####
  surface_type = unique(c('pial', additional_surface_type))
  surfaces = list(); surf = NULL

  for( surf_t in surface_type ){
    surf_lh = NULL; surf_rh = NULL
    surf_group = GeomGroup$new(name = sprintf('Surface - %s (%s)', surf_t, subject_name),
                               position = mesh_center)
    surf_group$subject_code = subject_name
    if( use_141 ){
      # Load surface from 141 cache
      cache_lh = file.path(path_cache, sprintf('%s_std_141_lh_%s.json', subject_name, surf_t))
      cache_rh = file.path(path_cache, sprintf('%s_std_141_rh_%s.json', subject_name, surf_t))
      if( use_cache && file.exists(cache_lh) && file.exists(cache_rh) ){
        surf_lh = FreeGeom$new(name = sprintf('Standard 141 Left Hemisphere - %s (%s)', surf_t, subject_name),
                               position = c(0,0,0), cache_file = cache_lh, group = surf_group, layer = 8)
        surf_rh = FreeGeom$new(name = sprintf('Standard 141 Right Hemisphere - %s (%s)', surf_t, subject_name),
                               position = c(0,0,0), cache_file = cache_rh, group = surf_group, layer = 8)
        surf_lh$subject_code = subject_name; surf_lh$hemisphere = 'left'; surf_lh$surface_type = surf_t;
        surf_rh$subject_code = subject_name; surf_rh$hemisphere = 'right'; surf_rh$surface_type = surf_t;
        surfaces[[surf_t]] = list(
          type = surf_t,
          sub_type = 'std.141',
          left = surf_lh,
          right = surf_rh
        )
      }else{
        unlink(cache_lh)
        unlink(cache_rh)
      }
      if(is.null(surf_lh)){
        # try to locate std.141.lh.xxx in SUMA folder
        surf = load_141_surface( path_suma, surf_t = surf_t, quiet = TRUE )
        if( is.null(surf) ){
          # Cannot find any surface
          use_141 = FALSE
        }else{
          surf_lh = FreeGeom$new(name = sprintf('Standard 141 Left Hemisphere - %s (%s)', surf_t, subject_name),
                                 position = c(0,0,0), vertex = surf$left$vertices, face = surf$left$faces,
                                 cache_file = cache_lh, group = surf_group, layer = 8)
          surf_rh = FreeGeom$new(name = sprintf('Standard 141 Right Hemisphere - %s (%s)', surf_t, subject_name),
                                 position = c(0,0,0), vertex = surf$right$vertices, face = surf$right$faces,
                                 cache_file = cache_rh, group = surf_group, layer = 8)
          surf_lh$subject_code = subject_name; surf_lh$hemisphere = 'left'; surf_lh$surface_type = surf_t;
          surf_rh$subject_code = subject_name; surf_rh$hemisphere = 'right'; surf_rh$surface_type = surf_t;
          surfaces[[surf_t]] = list(
            type = surf$type,
            sub_type = surf$sub_type,
            left = surf_lh,
            right = surf_rh
          )
        }
      }

    }

    if( !use_141 ){
      cache_lh = file.path(path_cache, sprintf('%s_fs_lh_%s.json', subject_name, surf_t))
      cache_rh = file.path(path_cache, sprintf('%s_fs_rh_%s.json', subject_name, surf_t))
      if( use_cache && file.exists(cache_lh) && file.exists(cache_rh) ){
        surf_lh = FreeGeom$new(name = sprintf('FreeSurfer Left Hemisphere - %s (%s)', surf_t, subject_name),
                               position = c(0,0,0), cache_file = cache_lh, group = surf_group, layer = 8)
        surf_rh = FreeGeom$new(name = sprintf('FreeSurfer Right Hemisphere - %s (%s)', surf_t, subject_name),
                               position = c(0,0,0), cache_file = cache_rh, group = surf_group, layer = 8)
        surf_lh$subject_code = subject_name; surf_lh$hemisphere = 'left'; surf_lh$surface_type = surf_t;
        surf_rh$subject_code = subject_name; surf_rh$hemisphere = 'right'; surf_rh$surface_type = surf_t;
        surfaces[[surf_t]] = list(
          type = surf_t,
          sub_type = 'fs',
          left = surf_lh,
          right = surf_rh
        )
      }else{
        unlink(cache_lh)
        unlink(cache_rh)
      }
      if(is.null(surf_lh)){
        # load from fs
        surf = load_fs_surface( path_surf, surf_t = surf_t, quiet = TRUE )
        surf_lh = FreeGeom$new(name = sprintf('FreeSurfer Left Hemisphere - %s (%s)', surf_t, subject_name),
                               position = c(0,0,0), vertex = surf$left$vertices, face = surf$left$faces,
                               cache_file = cache_lh, group = surf_group, layer = 8)
        surf_rh = FreeGeom$new(name = sprintf('FreeSurfer Right Hemisphere - %s (%s)', surf_t, subject_name),
                               position = c(0,0,0), vertex = surf$right$vertices, face = surf$right$faces,
                               cache_file = cache_rh, group = surf_group, layer = 8)
        surf_lh$subject_code = subject_name; surf_lh$hemisphere = 'left'; surf_lh$surface_type = surf_t;
        surf_rh$subject_code = subject_name; surf_rh$hemisphere = 'right'; surf_rh$surface_type = surf_t;
        surfaces[[surf_t]] = list(
          type = surf$type,
          sub_type = surf$sub_type,
          left = surf_lh,
          right = surf_rh
        )
      }
    }

  }

  rm(surf)

  surface_type = names(surfaces)
  if( !'pial' %in% surface_type ){
    cat2('Cannot find pial surface. Please make sure fs/SUMA/std.141.[lr]h.pial.asc or fs/surf/[lr]h.pial.asc exists', level = 'FATAL')
  }

  ##### return an environment ####
  env = new.env(parent = baseenv())
  env$path = list(
    path_subject = path_subject,
    path_cache = path_cache,
    path_brainfinal = path_brainfinal,
    path_rawavg = path_rawavg,
    path_xform = path_xform,
    path_suma = path_suma,
    path_surf = path_surf
  )
  env$transforms = list(
    vox2vox_MNI305 = vox2vox_MNI305,
    xfm = xfm,
    Norig = Norig,
    Torig = Torig,
    mesh_center = mesh_center
  )
  env$volume = geom_brain_finalsurfs
  env$surface_types = surface_type
  env$surfaces = surfaces
  env$subject = subject_name

  electrode_container = GeomGroup$new(name = sprintf('Electrodes (%s)', subject_name), position = c(0,0,0))
  electrode_container$subject_code = subject_name
  env$electrode_container = electrode_container
  env$electrodes = list()
  env$electrode_table = NULL

  # Function to add electrodes
  # Volume group:   Volume (YAB)
  # Volume:         brain.finalsurfs
  #
  # Surface group:  Surface - pial (YAB)
  # Surface         Standard 141 Right Hemisphere - pial
  #
  # Electrode container: Electrodes (YAB)
  # Electrode          : YAB, 1 - NA
  env$set_electrodes = function(tbl){
    if( missing(tbl) ){
      tbl = file.path(path_subject, '../meta/electrodes.csv')
    }
    if( !is.data.frame(tbl) ){
      # tbl is data path to electrode.csv

      # tbl = '~/rave_data/data_dir/congruency/YAB/rave/meta/electrodes.csv'
      tbl = read.csv(tbl, stringsAsFactors = FALSE)
    }
    if( !nrow(tbl) ){
      return(invisible())
    }

    if( length(tbl$SurfaceElectrode) && is.character(tbl$SurfaceElectrode) ){
      tbl$SurfaceElectrode = stringr::str_to_upper(tbl$SurfaceElectrode) == 'TRUE'
    }
    if( length( row$Hemisphere ) ){
      row$Hemisphere = stringr::str_to_lower(row$Hemisphere)
    }

    env$electrode_table = tbl

    # Coord_x Coord_y  Coord_z are required - in fs space
    for( ii in seq_len(nrow(tbl)) ){
      row = tbl[ii, ]
      radius = c(row$Radius, 2)[1]; if( isTRUE(row$isMini) ){ radius = radius * 0.5 }
      which_side = row$Hemisphere
      if( !is.null(which_side) && !is.na(which_side)){
        which_side = ifelse( which_side == 'left', 'left', 'right' )
      }
      nearest_vertex = c(row$VertexNumber, -1)[1]
      mni_305 = c( row$MNI305_x, row$MNI305_y, row$MNI305_z ); if(length(mni_305)!=3){ mni_305 = c(0,0,0) }
      surf_type = c(row$SurfaceType, 'pial')[1]
      if( is.na(surf_type) ){ surf_type = 'NA' }


      el = ElectrodeGeom$new(name = sprintf('%s, %d - %s', subject_name, row$Electrode, row$Label),
                     position = c(row$Coord_x, row$Coord_y, row$Coord_z),
                     radius = radius, group = electrode_container)
      el$is_surface_electrode = isTRUE( row$SurfaceElectrode )
      el$search_geoms = which_side
      el$surface_type = surf_type
      el$vertex_number = nearest_vertex
      el$subject_code = subject_name
      el$MNI305_position = mni_305
      env$electrodes[[ row$Electrode ]] = el
    }

  }


  # function to render
  env$view = function(
    time_range = NULL, value_range = NULL, symmetric = 0, side_camera = TRUE,
    control_panel = TRUE, show_legend = TRUE, legend_title = 'Value',
    color_ramp = c('navyblue', '#e2e2e2', 'red'),
    color_type = 'continuous', n_color = 64, color_names = seq_along(color_ramp),

    control_presets = c(
      'subject2', 'surface_type2', 'hemisphere_material', 'map_template',
      'animation' ),
      # 'electrodes', 'attach_to_surface', 'color_group', 'animation'),
    optionals = list(),
    width = NULL, height = NULL, debug = FALSE, token = NULL, browser_external = TRUE,

    # Might not need these
    camera_center = c(0, 0, 0), camera_pos = c(0, 0, 500), start_zoom = 1,
    side_camera_zoom = 1, tmp_dirname = NULL, coords = NULL, ...
  ){
    # collect volume information
    geoms = c(unlist(env$volume), unlist(env$surfaces), unlist(env$electrodes))
    is_r6 = vapply(geoms, function(x){
      !is.null(x) && R6::is.R6(x)
    }, FALSE)
    geoms = geoms[is_r6]
    names(geoms) = NULL

    global_data = structure(list(env$transforms), names = env$subject)

    threejs_brain(
      .list = geoms,
      time_range = time_range, value_range = value_range, symmetric = symmetric,
      side_camera = side_camera, side_camera_zoom = side_camera_zoom,
      control_panel = control_panel, control_presets = control_presets,
      camera_center = camera_center, camera_pos = camera_pos, start_zoom = start_zoom,
      color_ramp = color_ramp, color_type = color_type, n_color = n_color,
      color_names = color_names, show_legend = show_legend, legend_title = legend_title,
      tmp_dirname = tmp_dirname, width = width, height = height, optionals = optionals,
      debug = debug, token = token, coords = coords, browser_external = browser_external,
      global_data = global_data, ...)
  }
  return(env)

}


check_freesurfer_path <- function(fs_subject_folder, autoinstall = TRUE){
  if( dir.exists(fs_subject_folder) ){
    return(TRUE)
  }
}

electrode_mapped_141 <- function(position = c(0,0,0), is_surface, vertex_number, surf_type, hemisphere){
  surface_mapping = FALSE

  if( sum(position^2) == 0 ){
    return(TRUE)
  }

  if( isTRUE(is_surface) &&
      length(vertex_number) == 1 && vertex_number >= 0 &&
      length(surf_type) == 1 &&!is.na(surf_type) &&
      length(hemisphere) == 1 && hemisphere %in% c('right', 'left')){
    surface_mapping = TRUE
  }
  if( length(surf_type) == 1 && (is.na(surf_type) || surf_type == 'NA') ){
    # No need to map to surface as there is no surface
    surface_mapping = TRUE
  }
  return(surface_mapping)
}


merge_freesurfer_brain <- function(..., .list = NULL){

  # env = threeBrain:::freesurfer_brain(fs_subject_folder = '~/rave_data/data_dir/congruency/YAB','YAB', additional_surface_type = 'white');env$set_electrodes()
  # envn27 = threeBrain:::freesurfer_brain(fs_subject_folder = '~/rave_data/others/three_brain/test/N27/','N27')
  # envs = c(env, envn27)
  # merged_env = threeBrain:::merge_freesurfer_brain(env, envn27)
  envs = c(list(...), .list)

  subject_names = sapply(envs, '[[', 'subject')

  sel = !duplicated(subject_names)

  envs = envs[ sel ]
  subject_names = subject_names[ sel ]
  names(envs) = subject_names

  # TODO: Check whether N27 is present

  merged_env = new.env(parent = baseenv())
  merged_env$envs = envs
  merged_env$subject_names = subject_names
  merged_env$get_surface_types = function(){
    s = unlist(lapply(merged_env$envs, function(e){
      e$surface_types
    }))
    unique(s)
  }

  merged_env$view = function(
    template_subject = 'N27', template_subject_path = NULL,
    trim_memory = TRUE, force_trim = FALSE,
    time_range = NULL, value_range = NULL, symmetric = 0, side_camera = TRUE,
    control_panel = TRUE, show_legend = TRUE, legend_title = 'Value',
    color_ramp = c('navyblue', '#e2e2e2', 'red'),
    color_type = 'continuous', n_color = 64, color_names = seq_along(color_ramp),

    control_presets = c(
      'subject2', 'surface_type2', 'hemisphere_material', 'map_template',
      'animation' ),
    # 'electrodes', 'attach_to_surface', 'color_group', 'animation'),
    optionals = list(),
    width = NULL, height = NULL, debug = FALSE, token = NULL, browser_external = TRUE,

    # Might not need these
    camera_center = c(0, 0, 0), camera_pos = c(0, 0, 500), start_zoom = 1,
    side_camera_zoom = 1, tmp_dirname = NULL, coords = NULL,
    ...
  ){
    if( template_subject %in% merged_env$subject_names ){
      subject_names = unique(c(template_subject, merged_env$subject_names))
    }else{
      # load template subject
      if( is.null(template_subject_path) ){
        # try to load from ~/rave_data/others/threeBrain
        template_subject_path = file.path('~/rave_data/others/three_brain/test/', template_subject)
      }

      has_template = check_freesurfer_path( template_subject_path );

      if( !has_template ){
        cat2('Cannot find template subject - ', template_subject, level = 'WARNING')
        template_subject = subject_names[0]
      }else{
        template_env = freesurfer_brain(template_subject_path, template_subject,
                                        additional_surface_type = merged_env$get_surface_types(),
                                        use_cache = TRUE, use_141 = TRUE)
        merged_env$envs[[ template_subject ]] = template_env
        merged_env$subject_names = c(template_subject, merged_env$subject_names)
      }

    }
    envs = merged_env$envs
    subject_names = merged_env$subject_names
    # collect volume information
    geoms = lapply(subject_names, function(sub){

      if( isFALSE( trim_memory ) || sub == template_subject || (is.character(trim_memory) && !sub %in% trim_memory) ){
        return(c(unlist(envs[[sub]]$volume), unlist(envs[[sub]]$surfaces), unlist(envs[[sub]]$electrodes)))
      }else if(force_trim){
        return(unlist(envs[[sub]]$electrodes))
      }else{
        # check if electrodes has mappings
        tbl = envs[[sub]]$electrode_table
        if( is.data.frame(tbl) ){
          res = sapply(1:nrow(tbl), function(ii){
            row = tbl[ii,]
            re = TRUE
            if( isTRUE(row$SurfaceElectrode) ){
              re = electrode_mapped_141(position = c(row$Coord_x, row$Coord_y, row$Coord_z),
                                        is_surface = row$SurfaceElectrode,
                                        vertex_number = row$VertexNumber,
                                        surf_type = row$SurfaceType,
                                        hemisphere = row$Hemisphere)
            }
            re
          })
          if( all(res) ){
            return(unlist(envs[[sub]]$electrodes))
          }
        }
        # Only get ride of volume
        return(c(unlist(envs[[sub]]$surfaces), unlist(envs[[sub]]$electrodes)))
      }
    })

    if( trim_memory ){

    }else{
      # collect volume information
      geoms = lapply(subject_names, function(sub){
        c(unlist(envs[[sub]]$volume), unlist(envs[[sub]]$surfaces), unlist(envs[[sub]]$electrodes))
      })
    }


    geoms = unlist(geoms)
    is_r6 = vapply(geoms, function(x){ !is.null(x) && R6::is.R6(x) }, FALSE)
    geoms = geoms[is_r6]
    names(geoms) = NULL

    global_data = sapply(subject_names, function(subcode){
      envs[[ subcode ]]$transforms
    }, simplify = FALSE, USE.NAMES = TRUE);

    threejs_brain(
      .list = geoms,
      time_range = time_range, value_range = value_range, symmetric = symmetric,
      side_camera = side_camera, side_camera_zoom = side_camera_zoom,
      control_panel = control_panel, control_presets = control_presets,
      camera_center = camera_center, camera_pos = camera_pos, start_zoom = start_zoom,
      color_ramp = color_ramp, color_type = color_type, n_color = n_color,
      color_names = color_names, show_legend = show_legend, legend_title = legend_title,
      tmp_dirname = tmp_dirname, width = width, height = height, optionals = optionals,
      debug = debug, token = token, coords = coords, browser_external = browser_external,
      global_data = global_data, ...)
  }
  return(merged_env)
}





load_surface_asc_gii_nii <- function(file){
  nibabel = reticulate::import('nibabel')
  if( stringr::str_ends(stringr::str_to_lower(file), '\\.asc') ){
    surf = read_fs_asc(file)
    surf$vertices = surf$vertices[,1:3]
    surf$faces = surf$faces[,1:3]
  }else if( stringr::str_ends(stringr::str_to_lower(file), '\\.gii') ){
    tmp = nibabel$load(file)
    vertices = tmp$darrays[[1]]$data[,1:3]
    faces = tmp$darrays[[2]]$data[,1:3]
    surf = list(
      header = c(nrow(vertices), nrow(faces)),
      vertices = vertices,
      faces = faces
    )
  }else if( stringr::str_ends(stringr::str_to_lower(file), '\\.nii') ){
    stop('Support for Nifti file has not been implemented')
  }else{
    stop('Only support ASCII, Gifti, Nifti formats. Unknown type')
  }
  return(surf)
}

load_fs_surface <- function(dir, surf_t = 'pial', quiet = FALSE){
  # dir = "/Users/beauchamplab/rave_data/data_dir/congruency/YAB/rave/fs/SUMA"
  lh_file = list.files( dir, pattern = sprintf('^lh\\.%s\\.(asc|gii|nii)', surf_t), full.names = TRUE)
  rh_file = list.files( dir, pattern = sprintf('^rh\\.%s\\.(asc|gii|nii)', surf_t), full.names = TRUE)
  if(any( length(lh_file) == 0, length(rh_file) == 0 )){
    if(!quiet){
      cat2('Cannot find 141 brain from ', dir, level = 'ERROR')
    }
    return(invisible())
  }
  lh_file = sort(lh_file)[1]
  rh_file = sort(rh_file)[1]

  lh_surf = load_surface_asc_gii_nii(lh_file)
  rh_surf = load_surface_asc_gii_nii(rh_file)

  return(list(
    type = surf_t,
    sub_type = 'fs',
    left = lh_surf,
    right = rh_surf
  ))
}



load_141_surface <- function(dir, surf_t = 'pial', quiet = FALSE){
  # dir = "/Users/beauchamplab/rave_data/data_dir/congruency/YAB/rave/fs/SUMA"
  lh_file = list.files( dir, pattern = sprintf('^std\\.141\\.lh\\.%s\\.(asc|gii|nii)', surf_t), full.names = TRUE)
  rh_file = list.files( dir, pattern = sprintf('^std\\.141\\.rh\\.%s\\.(asc|gii|nii)', surf_t), full.names = TRUE)

  if(any( length(lh_file) == 0, length(rh_file) == 0 )){
    if(!quiet){
      cat2('Cannot find 141 brain from ', dir, level = 'ERROR')
    }
    return(invisible())
  }

  lh_file = sort(lh_file)[1]
  rh_file = sort(rh_file)[1]


  lh_surf = load_surface_asc_gii_nii(lh_file)
  rh_surf = load_surface_asc_gii_nii(rh_file)

  return(list(
    type = surf_t,
    sub_type = 'std.141',
    left = lh_surf,
    right = rh_surf
  ))

}

# env = threeBrain:::freesurfer_brain(fs_subject_folder = '~/rave_data/data_dir/congruency/YAB','YAB', additional_surface_type = 'white');env$set_electrodes('~/Downloads/YAB_electrodes (1).csv')
# merged_env = threeBrain:::merge_freesurfer_brain(env)
# merged_env$view(debug = TRUE)
