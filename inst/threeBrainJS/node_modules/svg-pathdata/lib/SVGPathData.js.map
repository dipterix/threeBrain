{"version":3,"file":"SVGPathData.js","sources":["../src/SVGPathDataEncoder.ts","../src/mathUtils.ts","../src/SVGPathDataTransformer.ts","../src/TransformableSVG.ts","../src/SVGPathDataParser.ts","../src/SVGPathData.ts"],"sourcesContent":["import { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand } from \"./types\";\n\n// Encode SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\n// Private consts : Char groups\nconst WSP = \" \";\n\nexport function encodeSVGPath(commands: SVGCommand | SVGCommand[]) {\n  let str = \"\";\n\n  if (!Array.isArray(commands)) {\n    commands = [commands];\n  }\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    if (command.type === SVGPathData.CLOSE_PATH) {\n      str += \"z\";\n    } else if (command.type === SVGPathData.HORIZ_LINE_TO) {\n      str += (command.relative ? \"h\" : \"H\") +\n        command.x;\n    } else if (command.type === SVGPathData.VERT_LINE_TO) {\n      str += (command.relative ? \"v\" : \"V\") +\n        command.y;\n    } else if (command.type === SVGPathData.MOVE_TO) {\n      str += (command.relative ? \"m\" : \"M\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.LINE_TO) {\n      str += (command.relative ? \"l\" : \"L\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.CURVE_TO) {\n      str += (command.relative ? \"c\" : \"C\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_CURVE_TO) {\n      str += (command.relative ? \"s\" : \"S\") +\n        command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.QUAD_TO) {\n      str += (command.relative ? \"q\" : \"Q\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_QUAD_TO) {\n      str += (command.relative ? \"t\" : \"T\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.ARC) {\n      str += (command.relative ? \"a\" : \"A\") +\n        command.rX + WSP + command.rY +\n        WSP + command.xRot +\n        WSP + (+command.lArcFlag) + WSP + (+command.sweepFlag) +\n        WSP + command.x + WSP + command.y;\n    } else {\n      // Unknown command\n      throw new Error(\n        `Unexpected command type \"${ (command as any).type}\" at index ${i}.`);\n    }\n  }\n\n  return str;\n}\n","import { SVGPathData } from \"./SVGPathData\";\nimport { CommandA, CommandC } from \"./types\";\n\nexport function rotate([x, y]: [number, number], rad: number) {\n  return [\n    x * Math.cos(rad) - y * Math.sin(rad),\n    x * Math.sin(rad) + y * Math.cos(rad),\n  ];\n}\n\nconst DEBUG_CHECK_NUMBERS = true;\nexport function assertNumbers(...numbers: number[]) {\n  if (DEBUG_CHECK_NUMBERS) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i]) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);\n      }\n    }\n  }\n  return true;\n}\n\nconst PI = Math.PI;\n\n/**\n * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n * Fixes rX and rY.\n * Ensures lArcFlag and sweepFlag are 0 or 1\n * Adds center coordinates: command.cX, command.cY (relative or absolute, depending on command.relative)\n * Adds start and end arc parameters (in degrees): command.phi1, command.phi2; phi1 < phi2 iff. c.sweepFlag == true\n */\nexport function annotateArcCommand(c: CommandA, x1: number, y1: number) {\n  c.lArcFlag = (0 === c.lArcFlag) ? 0 : 1;\n  c.sweepFlag = (0 === c.sweepFlag) ? 0 : 1;\n  // tslint:disable-next-line\n  let {rX, rY, x, y} = c;\n\n  rX = Math.abs(c.rX);\n  rY = Math.abs(c.rY);\n  const [x1_, y1_] = rotate([(x1 - x) / 2, (y1 - y) / 2], -c.xRot / 180 * PI);\n  const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);\n\n  if (1 < testValue) {\n    rX *= Math.sqrt(testValue);\n    rY *= Math.sqrt(testValue);\n  }\n  c.rX = rX;\n  c.rY = rY;\n  const c_ScaleTemp = (Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2));\n  const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) *\n    Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));\n  const cx_ = rX * y1_ / rY * c_Scale;\n  const cy_ = -rY * x1_ / rX * c_Scale;\n  const cRot = rotate([cx_, cy_], c.xRot / 180 * PI);\n\n  c.cX = cRot[0] + (x1 + x) / 2;\n  c.cY = cRot[1] + (y1 + y) / 2;\n  c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);\n  c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);\n  if (0 === c.sweepFlag && c.phi2 > c.phi1) {\n    c.phi2 -= 2 * PI;\n  }\n  if (1 === c.sweepFlag && c.phi2 < c.phi1) {\n    c.phi2 += 2 * PI;\n  }\n  c.phi1 *= 180 / PI;\n  c.phi2 *= 180 / PI;\n}\n\n/**\n * Solves a quadratic system of equations of the form\n *      a * x + b * y = c\n *      x² + y² = 1\n * This can be understood as the intersection of the unit circle with a line.\n *      => y = (c - a x) / b\n *      => x² + (c - a x)² / b² = 1\n *      => x² b² + c² - 2 c a x + a² x² = b²\n *      => (a² + b²) x² - 2 a c x + (c² - b²) = 0\n */\nexport function intersectionUnitCircleLine(a: number, b: number, c: number): [number, number][] {\n  assertNumbers(a, b, c);\n  // cf. pqFormula\n  const termSqr = a * a + b * b - c * c;\n\n  if (0 > termSqr) {\n    return [];\n  } else if (0 === termSqr) {\n    return [\n      [\n        (a * c) / (a * a + b * b),\n        (b * c) / (a * a + b * b)]];\n  }\n  const term = Math.sqrt(termSqr);\n\n  return [\n    [\n      (a * c + b * term) / (a * a + b * b),\n      (b * c - a * term) / (a * a + b * b)],\n    [\n      (a * c - b * term) / (a * a + b * b),\n      (b * c + a * term) / (a * a + b * b)]];\n\n}\n\nexport const DEG = Math.PI / 180;\n\nexport function lerp(a: number, b: number, t: number) {\n  return (1 - t) * a + t * b;\n}\n\nexport function arcAt(c: number, x1: number, x2: number, phiDeg: number) {\n  return c + Math.cos(phiDeg / 180 * PI) * x1 + Math.sin(phiDeg / 180 * PI) * x2;\n}\n\nexport function bezierRoot(x0: number, x1: number, x2: number, x3: number) {\n  const EPS = 1e-6;\n  const x01 = x1 - x0;\n  const x12 = x2 - x1;\n  const x23 = x3 - x2;\n  const a = 3 * x01 + 3 * x23 - 6 * x12;\n  const b = (x12 - x01) * 6;\n  const c = 3 * x01;\n  // solve a * t² + b * t + c = 0\n\n  if (Math.abs(a) < EPS) {\n    // equivalent to b * t + c =>\n    return [-c / b];\n  }\n  return pqFormula(b / a, c / a, EPS);\n\n}\n\nexport function bezierAt(x0: number, x1: number, x2: number, x3: number, t: number) {\n  // console.log(x0, y0, x1, y1, x2, y2, x3, y3, t)\n  const s = 1 - t;\n  const c0 = s * s * s;\n  const c1 = 3 * s * s * t;\n  const c2 = 3 * s * t * t;\n  const c3 = t * t * t;\n\n  return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;\n}\n\nfunction pqFormula(p: number, q: number, PRECISION = 1e-6) {\n  // 4 times the discriminant:in\n  const discriminantX4 = p * p / 4 - q;\n\n  if (discriminantX4 < -PRECISION) {\n    return [];\n  } else if (discriminantX4 <= PRECISION) {\n    return [-p / 2];\n  }\n  const root = Math.sqrt(discriminantX4);\n\n  return [-(p / 2) - root, -(p / 2) + root];\n\n}\n\nexport function a2c(arc: CommandA, x0: number, y0: number): CommandC[] {\n  if (!arc.cX) {\n    annotateArcCommand(arc, x0, y0);\n  }\n\n  const phiMin = Math.min(arc.phi1!, arc.phi2!), phiMax = Math.max(arc.phi1!, arc.phi2!), deltaPhi = phiMax - phiMin;\n  const partCount = Math.ceil(deltaPhi / 90 );\n\n  const result: CommandC[] = new Array(partCount);\n  let prevX = x0, prevY = y0;\n  for (let i = 0; i < partCount; i++) {\n    const phiStart = lerp(arc.phi1!, arc.phi2!, i / partCount);\n    const phiEnd = lerp(arc.phi1!, arc.phi2!, (i + 1) / partCount);\n    const deltaPhi = phiEnd - phiStart;\n    const f = 4 / 3 * Math.tan(deltaPhi * DEG / 4);\n    // x1/y1, x2/y2 and x/y coordinates on the unit circle for phiStart/phiEnd\n    const [x1, y1] = [\n      Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG),\n      Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG)];\n    const [x, y] = [Math.cos(phiEnd * DEG), Math.sin(phiEnd * DEG)];\n    const [x2, y2] = [x + f * Math.sin(phiEnd * DEG), y - f * Math.cos(phiEnd * DEG)];\n    result[i] = {relative: arc.relative, type: SVGPathData.CURVE_TO } as any;\n    const transform = (x: number, y: number) => {\n      const [xTemp, yTemp] = rotate([x * arc.rX, y * arc.rY], arc.xRot);\n      return [arc.cX! + xTemp, arc.cY! + yTemp];\n    };\n    [result[i].x1, result[i].y1] = transform(x1, y1);\n    [result[i].x2, result[i].y2] = transform(x2, y2);\n    [result[i].x, result[i].y] = transform(x, y);\n    if (arc.relative) {\n      result[i].x1 -= prevX;\n      result[i].y1 -= prevY;\n      result[i].x2 -= prevX;\n      result[i].y2 -= prevY;\n      result[i].x -= prevX;\n      result[i].y -= prevY;\n    }\n    [prevX, prevY] = [result[i].x, result[i].y];\n  }\n  return result;\n}\n","// Transform SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\nimport { a2c, annotateArcCommand, arcAt, assertNumbers, bezierAt, bezierRoot,\n  intersectionUnitCircleLine } from \"./mathUtils\";\nimport { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n\nexport namespace SVGPathDataTransformer {\n  // Predefined transforming functions\n  // Rounds commands values\n  export function ROUND(roundVal = 1e13) {\n    assertNumbers(roundVal);\n    function rf(val: number) { return Math.round(val * roundVal) / roundVal; }\n    return function round(command: any) {\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = rf(command.x1);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = rf(command.y1);\n      }\n\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = rf(command.x2);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = rf(command.y2);\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = rf(command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = rf(command.y);\n      }\n\n      if (\"undefined\" !== typeof command.rX) {\n        command.rX = rf(command.rX);\n      }\n      if (\"undefined\" !== typeof command.rY) {\n        command.rY = rf(command.rY);\n      }\n\n      return command;\n    };\n  }\n  // Relative to absolute commands\n  export function TO_ABS() {\n    return INFO((command, prevX, prevY) => {\n      if (command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 += prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 += prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x += prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y += prevY;\n        }\n        command.relative = false;\n      }\n      return command;\n    });\n  }\n  // Absolute to relative commands\n  export function TO_REL() {\n    return INFO((command, prevX, prevY) => {\n      if (!command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 -= prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 -= prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y -= prevY;\n        }\n        command.relative = true;\n      }\n      return command;\n    });\n  }\n  // Convert H, V, Z and A with rX = 0 to L\n  export function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true) {\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n      if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n      if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? pathStartX - prevX : pathStartX;\n        command.y = command.relative ? pathStartY - prevY : pathStartY;\n      }\n      if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {\n        command.type = SVGPathData.LINE_TO;\n        delete command.rX;\n        delete command.rY;\n        delete command.xRot;\n        delete command.lArcFlag;\n        delete command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  /*\n   * Transforms smooth curves and quads to normal curves and quads (SsTt to CcQq)\n   */\n  export function NORMALIZE_ST() {\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        command.type = SVGPathData.CURVE_TO;\n        prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;\n        prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;\n        command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;\n        command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;\n      }\n      if (command.type & SVGPathData.CURVE_TO) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;\n        command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;\n        command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y1;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      return command;\n    });\n  }\n  /*\n   * A quadratic bézier curve can be represented by a cubic bézier curve which has\n   * the same end points as the quadratic and both control points in place of the\n   * quadratic\"s one.\n   *\n   * This transformer replaces QqTt commands with Cc commands respectively.\n   * This is useful for reading path data into a system which only has a\n   * representation for cubic curves.\n   */\n  export function QT_TO_C() {\n    let prevQuadX1 = NaN;\n    let prevQuadY1 = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;\n        prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;\n        command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;\n        command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;\n        const x1 = command.x1;\n        const y1 = command.y1;\n\n        command.type = SVGPathData.CURVE_TO;\n        command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;\n        command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;\n        command.x2 = (command.x + x1 * 2) / 3;\n        command.y2 = (command.y + y1 * 2) / 3;\n      } else {\n        prevQuadX1 = NaN;\n        prevQuadY1 = NaN;\n      }\n\n      return command;\n    });\n  }\n  export function INFO(\n    f: (command: any, prevXAbs: number, prevYAbs: number,\n        pathStartXAbs: number, pathStartYAbs: number) => any | any[]) {\n    let prevXAbs = 0;\n    let prevYAbs = 0;\n    let pathStartXAbs = NaN;\n    let pathStartYAbs = NaN;\n\n    return function transform(command: any) {\n      if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n\n      const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        prevXAbs = pathStartXAbs;\n        prevYAbs = pathStartYAbs;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        prevXAbs = (command.relative ? prevXAbs + command.x : command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        prevYAbs = (command.relative ? prevYAbs + command.y : command.y);\n      }\n\n      if (command.type & SVGPathData.MOVE_TO) {\n        pathStartXAbs = prevXAbs;\n        pathStartYAbs = prevYAbs;\n      }\n\n      return result;\n    };\n  }\n  /*\n   * remove 0-length segments\n   */\n  export function SANITIZE(EPS = 0) {\n    assertNumbers(EPS);\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      const abs = Math.abs;\n      let skip = false;\n      let x1Rel = 0;\n      let y1Rel = 0;\n\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;\n        y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;\n      }\n      if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;\n      } else if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y2;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      if (command.type & SVGPathData.LINE_COMMANDS ||\n        command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) ||\n        command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO ||\n        command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        const xRel = \"undefined\" === typeof command.x ? 0 :\n          (command.relative ? command.x : command.x - prevX);\n        const yRel = \"undefined\" === typeof command.y ? 0 :\n          (command.relative ? command.y : command.y - prevY);\n\n        x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX :\n          \"undefined\" === typeof command.x1 ? x1Rel :\n            command.relative ? command.x :\n              command.x1 - prevX;\n        y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY :\n          \"undefined\" === typeof command.y1 ? y1Rel :\n            command.relative ? command.y :\n              command.y1 - prevY;\n\n        const x2Rel = \"undefined\" === typeof command.x2 ? 0 :\n          (command.relative ? command.x : command.x2 - prevX);\n        const y2Rel = \"undefined\" === typeof command.y2 ? 0 :\n          (command.relative ? command.y : command.y2 - prevY);\n\n        if (abs(xRel) <= EPS && abs(yRel) <= EPS &&\n          abs(x1Rel) <= EPS && abs(y1Rel) <= EPS &&\n          abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) {\n          skip = true;\n        }\n      }\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {\n          skip = true;\n        }\n      }\n\n      return skip ? [] : command;\n    });\n  }\n  // SVG Transforms : http://www.w3.org/TR/SVGTiny12/coords.html#TransformList\n  // Matrix : http://apike.ca/prog_svg_transform.html\n  // a c e\n  // b d f\n  export function MATRIX(a: number, b: number, c: number, d: number, e: number, f: number) {\n    assertNumbers(a, b, c, d, e, f);\n\n    return INFO((command, prevX, prevY, pathStartX) => {\n      const origX1 = command.x1;\n      const origX2 = command.x2;\n      // if isNaN(pathStartX), then this is the first command, which is ALWAYS an\n      // absolute MOVE_TO, regardless what the relative flag says\n      const comRel = command.relative && !isNaN(pathStartX);\n      const x = \"undefined\" !== typeof command.x ? command.x : (comRel ? 0 : prevX);\n      const y = \"undefined\" !== typeof command.y ? command.y : (comRel ? 0 : prevY);\n\n      if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = (command.x * a) + (y * c) + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = (x * b) + command.y * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);\n      }\n      function sqr(x: number) { return x * x; }\n      const det = a * d - b * c;\n\n      if (\"undefined\" !== typeof command.xRot) {\n        // Skip if this is a pure translation\n        if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {\n          // Special case for singular matrix\n          if (0 === det) {\n            // In the singular case, the arc is compressed to a line. The actual geometric image of the original\n            // curve under this transform possibly extends beyond the starting and/or ending points of the segment, but\n            // for simplicity we ignore this detail and just replace this command with a single line segment.\n            delete command.rX;\n            delete command.rY;\n            delete command.xRot;\n            delete command.lArcFlag;\n            delete command.sweepFlag;\n            command.type = SVGPathData.LINE_TO;\n          } else {\n            // Convert to radians\n            const xRot = command.xRot * Math.PI / 180;\n\n            // Convert rotated ellipse to general conic form\n            // x0^2/rX^2 + y0^2/rY^2 - 1 = 0\n            // x0 = x*cos(xRot) + y*sin(xRot)\n            // y0 = -x*sin(xRot) + y*cos(xRot)\n            // --> A*x^2 + B*x*y + C*y^2 - 1 = 0, where\n            const sinRot = Math.sin(xRot);\n            const cosRot = Math.cos(xRot);\n            const xCurve = 1 / sqr(command.rX);\n            const yCurve = 1 / sqr(command.rY);\n            const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;\n            const B = 2 * sinRot * cosRot * (xCurve - yCurve);\n            const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;\n\n            // Apply matrix to A*x^2 + B*x*y + C*y^2 - 1 = 0\n            // x1 = a*x + c*y\n            // y1 = b*x + d*y\n            //      (we can ignore e and f, since pure translations don\"t affect the shape of the ellipse)\n            // --> A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 = 0, where\n            const A1 = A * d * d - B * b * d + C * b * b;\n            const B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);\n            const C1 = A * c * c - B * a * c + C * a * a;\n\n            // Unapply newXRot to get back to axis-aligned ellipse equation\n            // x1 = x2*cos(newXRot) - y2*sin(newXRot)\n            // y1 = x2*sin(newXRot) + y2*cos(newXRot)\n            // A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 =\n            //   x2^2*(A1*cos(newXRot)^2 + B1*sin(newXRot)*cos(newXRot) + C1*sin(newXRot)^2)\n            //   + x2*y2*(2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2))\n            //   + y2^2*(A1*sin(newXRot)^2 - B1*sin(newXRot)*cos(newXRot) + C1*cos(newXRot)^2)\n            //   (which must have the same zeroes as)\n            // x2^2/newRX^2 + y2^2/newRY^2 - 1\n            //   (so we have)\n            // 2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2) = 0\n            // (A1 - C1)*sin(2*newXRot) = B1*cos(2*newXRot)\n            // 2*newXRot = atan2(B1, A1 - C1)\n            const newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;\n            // For any integer n, (atan2(B1, A1 - C1) + n*pi)/2 is a solution to the above; incrementing n just swaps\n            // the x and y radii computed below (since that\"s what rotating an ellipse by pi/2 does).  Choosing the\n            // rotation between 0 and pi/2 eliminates the ambiguity and leads to more predictable output.\n\n            // Finally, we get newRX and newRY from the same-zeroes relationship that gave us newXRot\n            const newSinRot = Math.sin(newXRot);\n            const newCosRot = Math.cos(newXRot);\n\n            command.rX = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));\n            command.rY = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));\n            command.xRot = newXRot * 180 / Math.PI;\n          }\n        }\n      }\n      // sweepFlag needs to be inverted when mirroring shapes\n      // see http://www.itk.ilstu.edu/faculty/javila/SVG/SVG_drawing1/elliptical_curve.htm\n      // m 65,10 a 50,25 0 1 0 50,25\n      // M 65,60 A 50,25 0 1 1 115,35\n      if (\"undefined\" !== typeof command.sweepFlag && 0 > det) {\n        command.sweepFlag = +!command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  export function ROTATE(a: number, x = 0, y = 0) {\n    assertNumbers(a, x, y);\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);\n  }\n  export function TRANSLATE(dX: number, dY = 0) {\n    assertNumbers(dX, dY);\n    return MATRIX(1, 0, 0, 1, dX, dY);\n  }\n  export function SCALE(dX: number, dY = dX) {\n    assertNumbers(dX, dY);\n    return MATRIX(dX, 0, 0, dY, 0, 0);\n  }\n  export function SKEW_X(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, 0, Math.atan(a), 1, 0, 0);\n  }\n  export function SKEW_Y(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, Math.atan(a), 0, 1, 0, 0);\n  }\n  export function X_AXIS_SYMMETRY(xOffset = 0) {\n    assertNumbers(xOffset);\n    return MATRIX(-1, 0, 0, 1, xOffset, 0);\n  }\n  export function Y_AXIS_SYMMETRY(yOffset = 0) {\n    assertNumbers(yOffset);\n    return MATRIX(1, 0, 0, -1, 0, yOffset);\n  }\n  // Convert arc commands to curve commands\n  export function A_TO_C() {\n    return INFO((command, prevX, prevY) => {\n      if (SVGPathData.ARC === command.type) {\n        return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);\n      }\n      return command;\n    });\n  }\n  // @see annotateArcCommand\n  export function ANNOTATE_ARCS() {\n    return INFO((c, x1, y1) => {\n      if (c.relative) {\n        x1 = 0;\n        y1 = 0;\n      }\n      if (SVGPathData.ARC === c.type) {\n        annotateArcCommand(c, x1, y1);\n      }\n      return c;\n    });\n  }\n  export function CLONE() {\n    return (c: SVGCommand) => {\n      const result = {} as SVGCommand;\n      // tslint:disable-next-line\n      for (const key in c) {\n        result[key as keyof SVGCommand] = c[key as keyof SVGCommand];\n      }\n      return result;\n    };\n  }\n  // @see annotateArcCommand\n  export function CALCULATE_BOUNDS() {\n    const clone = CLONE();\n    const toAbs = TO_ABS();\n    const qtToC = QT_TO_C();\n    const normST = NORMALIZE_ST();\n    const f: TransformFunction & {minX: number, maxX: number, minY: number, maxY: number} =\n        INFO((command, prevXAbs, prevYAbs) => {\n      const c = normST(qtToC(toAbs(clone(command))));\n      function fixX(absX: number) {\n        if (absX > f.maxX) { f.maxX = absX; }\n        if (absX < f.minX) { f.minX = absX; }\n      }\n      function fixY(absY: number) {\n        if (absY > f.maxY) { f.maxY = absY; }\n        if (absY < f.minY) { f.minY = absY; }\n      }\n      if (c.type & SVGPathData.DRAWING_COMMANDS) {\n        fixX(prevXAbs);\n        fixY(prevYAbs);\n      }\n      if (c.type & SVGPathData.HORIZ_LINE_TO) {\n        fixX(c.x);\n      }\n      if (c.type & SVGPathData.VERT_LINE_TO) {\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.LINE_TO) {\n        fixX(c.x);\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.CURVE_TO) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);\n\n        for (const derivRoot of xDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));\n          }\n        }\n        const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);\n\n        for (const derivRoot of yDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));\n          }\n        }\n      }\n      if (c.type & SVGPathData.ARC) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        annotateArcCommand(c, prevXAbs, prevYAbs);\n        // p = cos(phi) * xv + sin(phi) * yv\n        // dp = -sin(phi) * xv + cos(phi) * yv = 0\n        const xRotRad = c.xRot / 180 * Math.PI;\n        // points on ellipse for phi = 0° and phi = 90°\n        const x0 = Math.cos(xRotRad) * c.rX;\n        const y0 = Math.sin(xRotRad) * c.rX;\n        const x90 = -Math.sin(xRotRad) * c.rY;\n        const y90 = Math.cos(xRotRad) * c.rY;\n\n        // annotateArcCommand returns phi1 and phi2 such that -180° < phi1 < 180° and phi2 is smaller or greater\n        // depending on the sweep flag. Calculate phiMin, phiMax such that -180° < phiMin < 180° and phiMin < phiMax\n        const [phiMin, phiMax] = c.phi1 < c.phi2 ?\n          [c.phi1, c.phi2] :\n          (-180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1]);\n        const normalizeXiEta = ([xi, eta]: [number, number]) => {\n          const phiRad = Math.atan2(eta, xi);\n          const phi = phiRad * 180 / Math.PI;\n\n          return phi < phiMin ? phi + 360 : phi;\n        };\n        // xi = cos(phi), eta = sin(phi)\n\n        const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);\n        for (const derivRoot of xDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixX(arcAt(c.cX, x0, x90, derivRoot));\n          }\n        }\n\n        const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);\n        for (const derivRoot of yDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixY(arcAt(c.cY, y0, y90, derivRoot));\n          }\n        }\n      }\n      return command;\n    }) as any;\n\n    f.minX = Infinity;\n    f.maxX = -Infinity;\n    f.minY = Infinity;\n    f.maxY = -Infinity;\n    return f;\n  }\n}\n","import { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformFunction } from \"./types\";\n\nexport abstract class TransformableSVG {\n  round(x?: number) {\n    return this.transform(SVGPathDataTransformer.ROUND(x));\n  }\n\n  toAbs() {\n    return this.transform(SVGPathDataTransformer.TO_ABS());\n  }\n\n  toRel() {\n    return this.transform(SVGPathDataTransformer.TO_REL());\n  }\n\n  normalizeHVZ(a?: boolean, b?: boolean, c?: boolean) {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));\n  }\n\n  normalizeST() {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_ST());\n  }\n\n  qtToC() {\n    return this.transform(SVGPathDataTransformer.QT_TO_C());\n  }\n\n  aToC() {\n    return this.transform(SVGPathDataTransformer.A_TO_C());\n  }\n\n  sanitize(eps?: number) {\n    return this.transform(SVGPathDataTransformer.SANITIZE(eps));\n  }\n\n  translate(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.TRANSLATE(x, y));\n  }\n\n  scale(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.SCALE(x, y));\n  }\n\n  rotate(a: number, x?: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.ROTATE(a, x, y));\n  }\n\n  matrix(a: number, b: number, c: number, d: number, e: number, f: number) {\n    return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d, e, f));\n  }\n\n  skewX(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_X(a));\n  }\n\n  skewY(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_Y(a));\n  }\n\n  xSymmetry(xOffset?: number) {\n    return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));\n  }\n\n  ySymmetry(yOffset?: number) {\n    return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));\n  }\n\n  annotateArcs() {\n    return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());\n  }\n\n  abstract transform(transformFunction: TransformFunction): this;\n}\n","// Parse SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\nimport { COMMAND_ARG_COUNTS, SVGPathData } from \"./SVGPathData\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n// Private consts : Char groups\nconst isWhiteSpace = (c: string) =>\n  \" \" === c || \"\\t\" === c || \"\\r\" === c || \"\\n\" === c;\nconst isDigit = (c: string) =>\n  \"0\".charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= \"9\".charCodeAt(0);\nconst COMMANDS = \"mMzZlLhHvVcCsSqQtTaA\";\n\nexport class SVGPathDataParser extends TransformableSVG {\n  private curNumber: string = \"\";\n  private curCommandType: SVGCommand[\"type\"] | -1 = -1;\n  private curCommandRelative = false;\n  private canParseCommandOrComma = true;\n  private curNumberHasExp = false;\n  private curNumberHasExpDigits = false;\n  private curNumberHasDecimal = false;\n  private curArgs: number[] = [];\n\n  constructor() {\n    super();\n  }\n\n  finish(commands: SVGCommand[] = []) {\n    this.parse(\" \", commands);\n    // Adding residual command\n    if (0 !== this.curArgs.length || !this.canParseCommandOrComma) {\n      throw new SyntaxError(\"Unterminated command at the path end.\");\n    }\n    return commands;\n  }\n\n  parse(str: string, commands: SVGCommand[] = []) {\n    const finishCommand = (command: SVGCommand) => {\n      commands.push(command);\n      this.curArgs.length = 0;\n      this.canParseCommandOrComma = true;\n    };\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      // White spaces parsing\n      const isAArcFlag = this.curCommandType === SVGPathData.ARC &&\n        (this.curArgs.length === 3 || this.curArgs.length === 4) &&\n        this.curNumber.length === 1 &&\n        (this.curNumber === \"0\" || this.curNumber === \"1\");\n      const isEndingDigit = isDigit(c) && (\n        (this.curNumber === \"0\" && c === \"0\") ||\n        isAArcFlag\n      );\n\n      if (\n        isDigit(c) &&\n        !isEndingDigit\n      ) {\n        this.curNumber += c;\n        this.curNumberHasExpDigits = this.curNumberHasExp;\n        continue;\n      }\n      if (\"e\" === c || \"E\" === c) {\n        this.curNumber += c;\n        this.curNumberHasExp = true;\n        continue;\n      }\n      if (\n        (\"-\" === c || \"+\" === c) &&\n        this.curNumberHasExp &&\n        !this.curNumberHasExpDigits\n      ) {\n        this.curNumber += c;\n        continue;\n      }\n      // if we already have a \".\", it means we are starting a new number\n      if (\".\" === c && !this.curNumberHasExp && !this.curNumberHasDecimal && !isAArcFlag) {\n        this.curNumber += c;\n        this.curNumberHasDecimal = true;\n        continue;\n      }\n\n      // New number\n      if (this.curNumber && -1 !== this.curCommandType) {\n        const val = Number(this.curNumber);\n        if (isNaN(val)) {\n          throw new SyntaxError(`Invalid number ending at ${i}`);\n        }\n        if (this.curCommandType === SVGPathData.ARC) {\n          if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n            if (0 > val) {\n              throw new SyntaxError(\n                `Expected positive number, got \"${val}\" at index \"${i}\"`,\n              );\n            }\n          } else if (3 === this.curArgs.length || 4 === this.curArgs.length) {\n            if (\"0\" !== this.curNumber && \"1\" !== this.curNumber) {\n              throw new SyntaxError(\n                `Expected a flag, got \"${this.curNumber}\" at index \"${i}\"`,\n              );\n            }\n          }\n        }\n        this.curArgs.push(val);\n        if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {\n          if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.HORIZ_LINE_TO,\n              relative: this.curCommandRelative,\n              x: val,\n            });\n          } else if (SVGPathData.VERT_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.VERT_LINE_TO,\n              relative: this.curCommandRelative,\n              y: val,\n            });\n            // Move to / line to / smooth quadratic curve to commands (x, y)\n          } else if (\n            this.curCommandType === SVGPathData.MOVE_TO ||\n            this.curCommandType === SVGPathData.LINE_TO ||\n            this.curCommandType === SVGPathData.SMOOTH_QUAD_TO\n          ) {\n            finishCommand({\n              type: this.curCommandType,\n              relative: this.curCommandRelative,\n              x: this.curArgs[0],\n              y: this.curArgs[1],\n            } as SVGCommand);\n            // Switch to line to state\n            if (SVGPathData.MOVE_TO === this.curCommandType) {\n              this.curCommandType = SVGPathData.LINE_TO;\n            }\n          } else if (this.curCommandType === SVGPathData.CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.CURVE_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x2: this.curArgs[2],\n              y2: this.curArgs[3],\n              x: this.curArgs[4],\n              y: this.curArgs[5],\n            });\n          } else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.SMOOTH_CURVE_TO,\n              relative: this.curCommandRelative,\n              x2: this.curArgs[0],\n              y2: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.QUAD_TO) {\n            finishCommand({\n              type: SVGPathData.QUAD_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.ARC) {\n            finishCommand({\n              type: SVGPathData.ARC,\n              relative: this.curCommandRelative,\n              rX: this.curArgs[0],\n              rY: this.curArgs[1],\n              xRot: this.curArgs[2],\n              lArcFlag: this.curArgs[3] as 0 | 1,\n              sweepFlag: this.curArgs[4] as 0 | 1,\n              x: this.curArgs[5],\n              y: this.curArgs[6],\n            });\n          }\n        }\n        this.curNumber = \"\";\n        this.curNumberHasExpDigits = false;\n        this.curNumberHasExp = false;\n        this.curNumberHasDecimal = false;\n        this.canParseCommandOrComma = true;\n      }\n      // Continue if a white space or a comma was detected\n      if (isWhiteSpace(c)) {\n        continue;\n      }\n      if (\",\" === c && this.canParseCommandOrComma) {\n        // L 0,0, H is not valid:\n        this.canParseCommandOrComma = false;\n        continue;\n      }\n      // if a sign is detected, then parse the new number\n      if (\"+\" === c || \"-\" === c || \".\" === c) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = \".\" === c;\n        continue;\n      }\n      // if a 0 is detected, then parse the new number\n      if (isEndingDigit) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = false;\n        continue;\n      }\n\n      // Adding residual command\n      if (0 !== this.curArgs.length) {\n        throw new SyntaxError(`Unterminated command at index ${i}.`);\n      }\n      if (!this.canParseCommandOrComma) {\n        throw new SyntaxError(\n          `Unexpected character \"${c}\" at index ${i}. Command cannot follow comma`,\n        );\n      }\n      this.canParseCommandOrComma = false;\n      // Detecting the next command\n      if (\"z\" === c || \"Z\" === c) {\n        commands.push({\n          type: SVGPathData.CLOSE_PATH,\n        });\n        this.canParseCommandOrComma = true;\n        this.curCommandType = -1;\n        continue;\n        // Horizontal move to command\n      } else if (\"h\" === c || \"H\" === c) {\n        this.curCommandType = SVGPathData.HORIZ_LINE_TO;\n        this.curCommandRelative = \"h\" === c;\n        // Vertical move to command\n      } else if (\"v\" === c || \"V\" === c) {\n        this.curCommandType = SVGPathData.VERT_LINE_TO;\n        this.curCommandRelative = \"v\" === c;\n        // Move to command\n      } else if (\"m\" === c || \"M\" === c) {\n        this.curCommandType = SVGPathData.MOVE_TO;\n        this.curCommandRelative = \"m\" === c;\n        // Line to command\n      } else if (\"l\" === c || \"L\" === c) {\n        this.curCommandType = SVGPathData.LINE_TO;\n        this.curCommandRelative = \"l\" === c;\n        // Curve to command\n      } else if (\"c\" === c || \"C\" === c) {\n        this.curCommandType = SVGPathData.CURVE_TO;\n        this.curCommandRelative = \"c\" === c;\n        // Smooth curve to command\n      } else if (\"s\" === c || \"S\" === c) {\n        this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;\n        this.curCommandRelative = \"s\" === c;\n        // Quadratic bezier curve to command\n      } else if (\"q\" === c || \"Q\" === c) {\n        this.curCommandType = SVGPathData.QUAD_TO;\n        this.curCommandRelative = \"q\" === c;\n        // Smooth quadratic bezier curve to command\n      } else if (\"t\" === c || \"T\" === c) {\n        this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;\n        this.curCommandRelative = \"t\" === c;\n        // Elliptic arc command\n      } else if (\"a\" === c || \"A\" === c) {\n        this.curCommandType = SVGPathData.ARC;\n        this.curCommandRelative = \"a\" === c;\n      } else {\n        throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}.`);\n      }\n    }\n    return commands;\n  }\n  /**\n   * Return a wrapper around this parser which applies the transformation on parsed commands.\n   */\n  transform(transform: TransformFunction) {\n    const result = Object.create(this, {\n      parse: {\n        value(chunk: string, commands: SVGCommand[] = []) {\n          const parsedCommands = Object.getPrototypeOf(this).parse.call(\n            this,\n            chunk,\n          );\n          for (const c of parsedCommands) {\n            const cT = transform(c);\n            if (Array.isArray(cT)) {\n              commands.push(...cT);\n            } else {\n              commands.push(cT);\n            }\n          }\n          return commands;\n        },\n      },\n    });\n    return result as this;\n  }\n}\n","import { encodeSVGPath } from \"./SVGPathDataEncoder\";\nimport { SVGPathDataParser } from \"./SVGPathDataParser\";\nimport { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand } from \"./types\";\n\nexport class SVGPathData extends TransformableSVG {\n  commands: SVGCommand[];\n  constructor(content: string | SVGCommand[]) {\n    super();\n    if (\"string\" === typeof content) {\n      this.commands = SVGPathData.parse(content);\n    } else {\n      this.commands = content;\n    }\n  }\n\n  encode() {\n    return SVGPathData.encode(this.commands);\n  }\n\n  getBounds() {\n    const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n\n    this.transform(boundsTransform);\n    return boundsTransform;\n  }\n\n  transform(\n    transformFunction: (input: SVGCommand) => SVGCommand | SVGCommand[],\n  ) {\n    const newCommands = [];\n\n    for (const command of this.commands) {\n      const transformedCommand = transformFunction(command);\n\n      if (Array.isArray(transformedCommand)) {\n        newCommands.push(...transformedCommand);\n      } else {\n        newCommands.push(transformedCommand);\n      }\n    }\n    this.commands = newCommands;\n    return this;\n  }\n\n  static encode(commands: SVGCommand[]) {\n    return encodeSVGPath(commands);\n      }\n\n  static parse(path: string) {\n    const parser = new SVGPathDataParser();\n    const commands: SVGCommand[] = [];\n    parser.parse(path, commands);\n    parser.finish(commands);\n    return commands;\n  }\n\n  static readonly CLOSE_PATH: 1 = 1;\n  static readonly MOVE_TO: 2 = 2;\n  static readonly HORIZ_LINE_TO: 4 = 4;\n  static readonly VERT_LINE_TO: 8 = 8;\n  static readonly LINE_TO: 16 = 16;\n  static readonly CURVE_TO: 32 = 32;\n  static readonly SMOOTH_CURVE_TO: 64 = 64;\n  static readonly QUAD_TO: 128 = 128;\n  static readonly SMOOTH_QUAD_TO: 256 = 256;\n  static readonly ARC: 512 = 512;\n  static readonly LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n  static readonly DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO |\n  SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO |\n  SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;\n}\n\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n\nexport {encodeSVGPath} from \"./SVGPathDataEncoder\";\nexport {SVGPathDataParser} from \"./SVGPathDataParser\";\nexport {SVGPathDataTransformer} from \"./SVGPathDataTransformer\";\n"],"names":["encodeSVGPath","commands","str","Array","isArray","i","length","command","type","SVGPathData","CLOSE_PATH","HORIZ_LINE_TO","relative","x","VERT_LINE_TO","y","MOVE_TO","LINE_TO","CURVE_TO","x1","y1","x2","y2","SMOOTH_CURVE_TO","QUAD_TO","SMOOTH_QUAD_TO","ARC","Error","rX","rY","xRot","lArcFlag","sweepFlag","rotate","_a","rad","Math","cos","sin","assertNumbers","_i","numbers","PI","annotateArcCommand","c","abs","x1_","y1_","testValue","pow","sqrt","c_ScaleTemp","c_Scale","max","cx_","cy_","cRot","cX","cY","phi1","atan2","phi2","intersectionUnitCircleLine","a","b","termSqr","term","DEG","lerp","t","arcAt","phiDeg","bezierRoot","x0","x3","x01","x12","p","q","PRECISION","discriminantX4","root","pqFormula","bezierAt","s","SVGPathDataTransformer","TO_ABS","INFO","prevX","prevY","NORMALIZE_ST","prevCurveC2X","NaN","prevCurveC2Y","prevQuadCX","prevQuadCY","isNaN","QT_TO_C","prevQuadX1","prevQuadY1","f","prevXAbs","prevYAbs","pathStartXAbs","pathStartYAbs","result","MATRIX","d","e","pathStartX","origX1","origX2","comRel","sqr","det","sinRot","cosRot","xCurve","yCurve","A","B","C","A1","B1","C1","newXRot","newSinRot","newCosRot","CLONE","key","roundVal","rf","val","round","normalizeZ","normalizeH","normalizeV","pathStartY","EPS","skip","x1Rel","y1Rel","LINE_COMMANDS","xRel","yRel","x2Rel","y2Rel","dX","dY","atan","xOffset","yOffset","arc","y0","phiMin","min","deltaPhi","partCount","ceil","phiStart","phiEnd","deltaPhi_1","tan","_e","_f","_g","transform","xTemp","yTemp","_b","_c","_d","a2c","clone","toAbs","qtToC","normST","fixX","absX","maxX","minX","fixY","absY","maxY","minY","DRAWING_COMMANDS","xDerivRoots_1","derivRoot","yDerivRoots_1","xRotRad","x90","y90","phiMin_1","phiMax","normalizeXiEta","xi","eta","phi","xDerivRoots_2","map","yDerivRoots_2","Infinity","TransformableSVG","this","ROUND","TO_REL","NORMALIZE_HVZ","A_TO_C","eps","SANITIZE","TRANSLATE","SCALE","ROTATE","SKEW_X","SKEW_Y","X_AXIS_SYMMETRY","Y_AXIS_SYMMETRY","ANNOTATE_ARCS","isWhiteSpace","isDigit","charCodeAt","_super","_this","__extends","SVGPathDataParser","parse","curArgs","canParseCommandOrComma","SyntaxError","finishCommand","push","isAArcFlag","curCommandType","curNumber","isEndingDigit","curNumberHasExp","curNumberHasExpDigits","curNumberHasDecimal","Number","COMMAND_ARG_COUNTS","curCommandRelative","Object","create","value","chunk","parsedCommands_1","getPrototypeOf","call","cT","content","encode","boundsTransform","CALCULATE_BOUNDS","transformFunction","newCommands","transformedCommand","path","parser","finish"],"mappings":"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"}